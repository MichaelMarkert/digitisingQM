<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Basic Image Quality Analyzer</title>

<script>
  function loadExifJs() {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/exif-js';
    script.onerror = () => {
      const fallbackScript = document.createElement('script');
      fallbackScript.src = './exif.js';
      document.head.appendChild(fallbackScript);
    };
    document.head.appendChild(script);
  }
  loadExifJs();
</script>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #1e1e1e;
    color: #f5f5f5;
    margin: 0;
    padding: 1em;
    text-align: center;
  }

  #uploader { 
    margin: 2em;
    font-family: monospace; 
    font-weight: bold;
  }

  button {
    font-weight: bold;
    background: lightgrey;
    color: rgba(255, 0, 0, 0.4);
    border: none;
    padding: 0.5em 1em;
    margin: 0.5em;
    cursor: pointer;
    border-radius: 5px;
  }
  button:hover { background: #666; }

  #container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1em;
    justify-content: center;
    align-items: top;
    margin: auto;
    max-width: 80vw;
  }

  .canvas-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }

  #imageCanvas, #overlayCanvas {
    height: 300px; /* Matches histogram height */
    width: auto;
    display: block;
  }

  #overlayCanvas {
    position: absolute;
    pointer-events: none;
    display: none;
  }

  #histogramCombined {
    width: 100%;
    height: 300px; /* Same height as #imageCanvas */
    background: #111;
    border: 1px solid #444;
  }

  #tooltip {
    position: fixed;
    pointer-events: none;
    padding: 4px 8px;
    border-radius: 4px;
    background: rgba(0,0,0,0.8);
    color: #fff;
    font-size: 0.9em;
    display: none;
    white-space: nowrap;
    z-index: 10;
  }

  #blackWhiteStats, #exifData, #rgbDistribution {
    margin-top: 1em;
    font-weight: bold;
  }

  #toggleMargin {
    text-align:left;
  }

  .warning { color: #ff5555; }
  .good { color: #88ff88; }

  @media (max-width: 768px) {
    #container { 
      grid-template-columns: 1fr; 
    }
  }
</style>
</head>
<body>

<h1>Basic Image Quality Evaluation</h1>

<input type="file" id="uploader" accept="image/*"><button id="toggleMargin">Toggle margins (5%,5%,5%,10%)</button>
<div id="container">
  <div>
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="imageCanvas"></canvas>
      <canvas id="overlayCanvas"></canvas>
    </div>
    <div id="exifData">EXIF data will appear here if available.</div>
    <div id="rgbDistribution">Edge distribution: No data yet.</div>
  </div>
  <div>
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="histogramCombined"></canvas>
    </div>
    <div id="blackWhiteStats">No image loaded yet.</div>
  </div>
</div>
<div id="container">
  <div>
    
  </div>
</div>

<div id="tooltip"></div>

<script>
const uploader = document.getElementById('uploader');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlayCanvas');
const octx = overlay.getContext('2d');
const histCanvas = document.getElementById('histogramCombined');
const histCtx = histCanvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const toggleButton = document.getElementById('toggleMargin');
const blackWhiteStats = document.getElementById('blackWhiteStats');
const exifDataElem = document.getElementById('exifData');
const wrapper = document.getElementById('canvasWrapper');

let imgData = null;
let overlayVisible = false;
let imgWidth = 0, imgHeight = 0;

uploader.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const img = new Image();
  img.onload = () => {
    imgWidth = img.width;
    imgHeight = img.height;

    // Set actual canvas pixel sizes
    canvas.width = imgWidth;
    canvas.height = imgHeight;
    overlay.width = imgWidth;
    overlay.height = imgHeight;

    // Match CSS size to display proportionally
    const maxDisplayWidth = wrapper.clientWidth || window.innerWidth * 0.5;
    const scale = Math.min(maxDisplayWidth / imgWidth, 1);
    const displayWidth = imgWidth * scale;
    const displayHeight = imgHeight * scale;

    ctx.drawImage(img, 0, 0);
    imgData = ctx.getImageData(0,0,imgWidth,imgHeight);
    calculateEdgeRGB(imgData);
    drawHistogram(imgData);
    calcBlackWhite(imgData);
  };
  img.src = URL.createObjectURL(file);

  EXIF.getData(file, function() {
    const iso = EXIF.getTag(this, 'ISOSpeedRatings');
    const aperture = EXIF.getTag(this, 'FNumber');
    const exposure = EXIF.getTag(this, 'ExposureTime');
    displayEXIF(iso, aperture, exposure);
  });
});

// Tooltip behavior
canvas.addEventListener('mousemove', (e) => {
  if (!imgData) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(((e.clientX - rect.left) * canvas.width) / rect.width);
  const y = Math.floor(((e.clientY - rect.top) * canvas.height) / rect.height);
  const index = (y * imgData.width + x) * 4;
  const r = imgData.data[index];
  const g = imgData.data[index + 1];
  const b = imgData.data[index + 2];
  if (r === undefined) return;

  tooltip.textContent = `RGB(${r}, ${g}, ${b})`;
  const offset = 8;
  let left = e.clientX + offset;
  let top = e.clientY + offset;
  const maxLeft = window.innerWidth - tooltip.offsetWidth - 5;
  const maxTop = window.innerHeight - tooltip.offsetHeight - 5;
  if (left > maxLeft) left = e.clientX - tooltip.offsetWidth - offset;
  if (top > maxTop) top = e.clientY - tooltip.offsetHeight - offset;

  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
  tooltip.style.display = 'block';
  tooltip.style.background = `rgba(${r},${g},${b},0.9)`;
  tooltip.style.color = (r*0.299 + g*0.587 + b*0.114 > 128)?'#000':'#fff';
});
canvas.addEventListener('mouseleave', ()=> tooltip.style.display='none');

// Histogram
function drawHistogram(imageData){
  const histR=new Array(256).fill(0), histG=new Array(256).fill(0), histB=new Array(256).fill(0);
  for(let i=0;i<imageData.data.length;i+=4){
    histR[imageData.data[i]]++;
    histG[imageData.data[i+1]]++;
    histB[imageData.data[i+2]]++;
  }
  const w = histCanvas.width;
  const h = histCanvas.height;
  histCtx.clearRect(0,0,w,h);
  const maxVal = Math.max(...histR, ...histG, ...histB);
  const barWidth = w/256;
  histCtx.globalAlpha = 0.6;
  histCtx.fillStyle='red';
  histR.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.fillStyle='lime';
  histG.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.fillStyle='blue';
  histB.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.globalAlpha=1.0;
}

// Black/white pixel % 
function calcBlackWhite(imageData){
  const data=imageData.data;
  let black=0, white=0;
  for(let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2];
    if(r===0&&g===0&&b===0) black++;
    else if(r===255&&g===255&&b===255) white++;
  }
  const total=data.length/4;
  const blackPct=(black/total*100).toFixed(2);
  const whitePct=(white/total*100).toFixed(2);
  let msg=`Black: ${blackPct}% | White: ${whitePct}%`;
  if(blackPct>5||whitePct>5){msg+=' ⚠️';blackWhiteStats.classList.add('warning');}
  else blackWhiteStats.classList.remove('warning');
  blackWhiteStats.textContent=msg;
}

//EdgeRGB
function calculateEdgeRGB(imgData) {
  const { width, height, data } = imgData;

  // Define circle radius as 5% of the image width
  const radius = Math.floor(width * 0.05);

  // Define the 4 edge points (10% horizontally and vertically)
  const points = [
    { name: "<br>topL", x: Math.floor(width * 0.1), y: Math.floor(height * 0.1) },
    { name: "topR", x: Math.floor(width * 0.9), y: Math.floor(height * 0.1) },
    { name: "<br>botL", x: Math.floor(width * 0.1), y: Math.floor(height * 0.9) },
    { name: "botR", x: Math.floor(width * 0.9), y: Math.floor(height * 0.9) },
  ];

  let results = "";

  points.forEach(({ name, x, y }) => {
    let totalR = 0, totalG = 0, totalB = 0;

    // Choose 10 random pixels within the circle
    for (let i = 0; i < 10; i++) {
      const angle = Math.random() * 2 * Math.PI; // Random angle
      const distance = Math.random() * radius;  // Random distance within radius
      const px = Math.floor(x + distance * Math.cos(angle));
      const py = Math.floor(y + distance * Math.sin(angle));

      // Ensure the pixel is within bounds
      if (px >= 0 && px < width && py >= 0 && py < height) {
        const index = (py * width + px) * 4;
        totalR += data[index];     // Red channel
        totalG += data[index + 1]; // Green channel
        totalB += data[index + 2]; // Blue channel
      }
    }

    // Calculate the average RGB values
    const avgR = Math.round(totalR / 10);
    const avgG = Math.round(totalG / 10);
    const avgB = Math.round(totalB / 10);

    // Append the result to the display string
    results += `${name}: ${avgR},${avgG},${avgB} `;
  });

  // Remove the trailing semicolon and space
  results = results.trim().replace(/;$/, "");

  // Display the results on the website
  const rgbDistributionElem = document.getElementById('rgbDistribution');
  rgbDistributionElem.innerHTML = `Edge distribution: ${results}`;
}

// EXIF
function displayEXIF(iso, aperture, exposure){
  if(!iso&&!aperture&&!exposure){exifDataElem.textContent="No EXIF.";return;}
  let shutter='N/A';
  if(exposure){shutter=exposure>=1?`${exposure.toFixed(2)}s`:`1/${Math.round(1/exposure)}`;}
  let msg=`ISO:${iso||'N/A'} | Aperture:f/${aperture?aperture.toFixed(1):'?'} | Shutter:${shutter}`;
  exifDataElem.textContent=msg;
  exifDataElem.classList.remove('good','warning');
  if((iso>200)||(aperture&&(aperture<8||aperture>16))||(exposure>1)){
    exifDataElem.classList.add('warning');
    exifDataElem.textContent+=' ⚠️ Exposure check!';
  }else exifDataElem.classList.add('good');
}

// Toggle overlay
toggleButton.addEventListener('click',()=>{
  if(!imgData) return;
  overlayVisible=!overlayVisible;
  overlay.style.display=overlayVisible?'block':'none';
  if(overlayVisible) drawRedMargins();
});

function drawRedMargins() {
  octx.clearRect(0, 0, overlay.width, overlay.height);
  const mw = overlay.width * 0.05;
  const mh = overlay.height * 0.05;
  const mhb = overlay.height * 0.1;

  octx.fillStyle = "rgba(255, 0, 0, 0.4)"; // semi-transparent red bands

  octx.fillRect(0, 0, mw, overlay.height);
  octx.fillRect(overlay.width - mw, 0, mw, overlay.height);
  octx.fillRect(0, 0, overlay.width, mh);
  octx.fillRect(0, overlay.height - mhb, overlay.width, mhb);

}
</script>
</body>
</html>