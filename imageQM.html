<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Basic Image Quality Analyzer</title>

<script>
  function loadExifJs() {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tiff.js';
    script.onerror = () => {
      const fallbackScript = document.createElement('script');
      fallbackScript.src = './tiff.js';
      document.head.appendChild(fallbackScript);
    };
    document.head.appendChild(script);
  }
  loadExifJs();
</script>

<!-- <script>
  function loadExifJs() {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/exif-js';
    script.onerror = () => {
      const fallbackScript = document.createElement('script');
      fallbackScript.src = './exif-js.js';
      document.head.appendChild(fallbackScript);
    };
    document.head.appendChild(script);
  }
  loadExifJs();
</script> -->

<script>
  function loadExifJs() {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/exifreader@4.32.0/dist/exif-reader.js';
    script.onerror = () => {
      const fallbackScript = document.createElement('script');
      fallbackScript.src = './exif-reader.js';
      document.head.appendChild(fallbackScript);
    };
    document.head.appendChild(script);
  }
  loadExifJs();
</script>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #1e1e1e;
    color: #f5f5f5;
    margin: 0;
    padding: 1em;
    text-align: center;
  }

  input[type="file"] {
      display: none;
  }

  .custom-file-upload {
    border: 1px solid #ccc;
    display: inline-block;
    padding: 6px 12px;
    cursor: pointer;
    font-family: monospace; 
    font-weight: bold;
  }

  .custom-file-upload:hover { background: #666; }

  button {
    background: #1e1e1e;
    border: 1px solid #ccc;
    display: inline-block;
    padding: 6px 12px;
    cursor: pointer;
    margin: 2em;
    font-family: monospace; 
    font-weight: bold;
    font-weight: bold;
    color: rgba(255, 77, 77, 0.6);
  }

  button:hover { background: #666; }

  #container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1em;
    justify-content: center;
    align-items: top;
    margin: auto;
    max-width: 80vw;
  }

  .canvas-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    position: relative;
  }

  #imageCanvas, #overlayCanvas, #gridCanvas {
    height: 300px; /* Matches histogram height */
    width: auto;
    display: block;
  }

  #overlayCanvas, #gridCanvas {
    position: absolute;
    pointer-events: none;
    display: none;
  }

  #histogramCombined {
    width: 100%;
    height: 300px; /* Same height as #imageCanvas */
    background: #111;
    border: 1px solid #444;
  }

  #tooltip {
    position: fixed;
    pointer-events: none;
    padding: 4px 8px;
    border-radius: 4px;
    background: rgba(0,0,0,0.8);
    color: #fff;
    font-size: 0.9em;
    display: none;
    white-space: nowrap;
    z-index: 10;
  }

  #blackWhiteStats, #exifData, #rgbDistribution {
    margin-top: 1em;
    font-weight: bold;
  }

  #toggleMargin, #toggleGrid {
    text-align:left;
  }

  .warning { color: #ff5555; }
  .good { color: #88ff88; }

  @media (max-width: 768px) {
    #container { 
      grid-template-columns: 1fr; 
    }
  }
</style>
</head>
<body>

<h1>Basic Image Quality Evaluation</h1>

<label class="custom-file-upload"><input type="file" id="uploader" accept="image/*">Upload image</label><br>
<button id="toggleMargin">Toggle margins (5%,5%,5%,10%)</button>
<button id="toggleGrid">Toggle grid overlay</button>

<div id="container">
  <div>
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="imageCanvas"></canvas>
      <canvas id="overlayCanvas"></canvas>
      <canvas id="gridCanvas"></canvas>
    </div>
    <div id="exifData">EXIF data will appear here if available.</div>
    <div id="rgbDistribution">Edge distribution: No data yet.</div>
  </div>
  <div>
    <div class="canvas-wrapper" id="canvasWrapper">
      <canvas id="histogramCombined"></canvas>
    </div>
    <div id="blackWhiteStats">No image loaded yet.</div>
  </div>
</div>

<div id="tooltip"></div>

<script>
const uploader = document.getElementById('uploader');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlayCanvas');
const octx = overlay.getContext('2d');
const gridCanvas = document.getElementById('gridCanvas');
const gctx = gridCanvas.getContext('2d');
const histCanvas = document.getElementById('histogramCombined');
const histCtx = histCanvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const toggleButton = document.getElementById('toggleMargin');
const toggleGridButton = document.getElementById('toggleGrid');
const blackWhiteStats = document.getElementById('blackWhiteStats');
const exifDataElem = document.getElementById('exifData');
const wrapper = document.getElementById('canvasWrapper');

let imgData = null;
let overlayVisible = false;
let gridVisible = false;
let imgWidth = 0, imgHeight = 0;

uploader.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const fileReader = new FileReader();
  
  fileReader.onload = (event) => {
    const arrayBuffer = event.target.result;

    if (file.name.endsWith('.tif') || file.name.endsWith('.tiff')) {
      Tiff.initialize({TOTAL_MEMORY: 524288000}); // Initialize the memory with 500MB for TIFF
      const tiff = new Tiff({ buffer: arrayBuffer });
      const image = tiff.toCanvas();
      if (image) {
        imgWidth = image.width;
        imgHeight = image.height;

        canvas.width = imgWidth;
        canvas.height = imgHeight;
        overlay.width = imgWidth;
        overlay.height = imgHeight;
        gridCanvas.width = imgWidth;
        gridCanvas.height = imgHeight;

        ctx.drawImage(image, 0, 0);

        imgData = ctx.getImageData(0, 0, imgWidth, imgHeight);
        calculateEdgeRGB(imgData);
        drawHistogram(imgData);
        calcBlackWhite(imgData);
      }
    } else {
      const img = new Image();
      img.onload = () => {
        imgWidth = img.width;
        imgHeight = img.height;

        canvas.width = imgWidth;
        canvas.height = imgHeight;
        overlay.width = imgWidth;
        overlay.height = imgHeight;
        gridCanvas.width = imgWidth;
        gridCanvas.height = imgHeight;

        ctx.drawImage(img, 0, 0);
        imgData = ctx.getImageData(0, 0, imgWidth, imgHeight);
        calculateEdgeRGB(imgData);
        drawHistogram(imgData);
        calcBlackWhite(imgData);
      };
      img.src = URL.createObjectURL(file);
    };
  };

  fileReader.readAsArrayBuffer(file);

/*   EXIF.getData(file, function() {
    const iso = EXIF.getTag(this, 'ISOSpeedRatings');
    const aperture = EXIF.getTag(this, 'FNumber');
    const exposure = EXIF.getTag(this, 'ExposureTime');
    console.log(iso,aperture,exposure);
    displayEXIF(iso, aperture, exposure);
  });  */

function computeFraction(fractionArray) {
    if (fractionArray.length === 2) {
        const [numerator, denominator] = fractionArray; 
        return numerator / denominator;
    } else if (fractionArray.length === 1) {
        return fractionArray[0] / 1;
    } else {
        throw new Error("Fraction must have one or two elements.");
    }
}

async function processExifData(file) {
  const tags = await ExifReader.load(file);
  console.log(tags);
  const iso = tags['ISOSpeedRatings'] ? tags['ISOSpeedRatings'].value : undefined;
  const aperture = tags['FNumber'] ? computeFraction(tags['FNumber'].value) : undefined;
  const exposure = tags['ExposureTime'] ? computeFraction(tags['ExposureTime'].value) : undefined;
  displayEXIF(iso, aperture, exposure);
};

processExifData(file);

});

canvas.addEventListener('mousemove', (e) => {
  if (!imgData) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(((e.clientX - rect.left) * canvas.width) / rect.width);
  const y = Math.floor(((e.clientY - rect.top) * canvas.height) / rect.height);
  const index = (y * imgData.width + x) * 4;
  const r = imgData.data[index];
  const g = imgData.data[index + 1];
  const b = imgData.data[index + 2];
  if (r === undefined) return;

  tooltip.textContent = `RGB(${r}, ${g}, ${b})`;
  const offset = 8;
  let left = e.clientX + offset;
  let top = e.clientY + offset;
  const maxLeft = window.innerWidth - tooltip.offsetWidth - 5;
  const maxTop = window.innerHeight - tooltip.offsetHeight - 5;
  if (left > maxLeft) left = e.clientX - tooltip.offsetWidth - offset;
  if (top > maxTop) top = e.clientY - tooltip.offsetHeight - offset;

  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
  tooltip.style.display = 'block';
  tooltip.style.background = `rgba(${r},${g},${b},0.9)`;
  tooltip.style.color = (r*0.299 + g*0.587 + b*0.114 > 128)?'#000':'#fff';
});
canvas.addEventListener('mouseleave', ()=> tooltip.style.display='none');

function drawHistogram(imageData){
  const histR=new Array(256).fill(0), histG=new Array(256).fill(0), histB=new Array(256).fill(0);
  for(let i=0;i<imageData.data.length;i+=4){
    histR[imageData.data[i]]++;
    histG[imageData.data[i+1]]++;
    histB[imageData.data[i+2]]++;
  }
  const w = histCanvas.width;
  const h = histCanvas.height;
  histCtx.clearRect(0,0,w,h);
  const maxVal = Math.max(...histR, ...histG, ...histB);
  const barWidth = w/256;
  histCtx.globalAlpha = 0.6;
  histCtx.fillStyle='red';
  histR.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.fillStyle='lime';
  histG.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.fillStyle='blue';
  histB.forEach((v,i)=>histCtx.fillRect(i*barWidth,h-(v/maxVal)*h,barWidth,(v/maxVal)*h));
  histCtx.globalAlpha=1.0;
}

function calcBlackWhite(imageData){
  const data=imageData.data;
  let black=0, white=0;
  for(let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2];
    if(r===0&&g===0&&b===0) black++;
    else if(r===255&&g===255&&b===255) white++;
  }
  const total=data.length/4;
  const blackPct=(black/total*100).toFixed(2);
  const whitePct=(white/total*100).toFixed(2);
  let msg=`Black: ${blackPct}% | White: ${whitePct}%`;
  if(blackPct>5||whitePct>5){msg+=' ⚠️';blackWhiteStats.classList.add('warning');}
  else blackWhiteStats.classList.remove('warning');
  blackWhiteStats.textContent=msg;
}

function calculateEdgeRGB(imgData) {
  const { width, height, data } = imgData;
  const radius = Math.floor(width * 0.05);
  const points = [
    { name: "<br>topL", x: Math.floor(width * 0.1), y: Math.floor(height * 0.1) },
    { name: "topR", x: Math.floor(width * 0.9), y: Math.floor(height * 0.1) },
    { name: "<br>botL", x: Math.floor(width * 0.1), y: Math.floor(height * 0.9) },
    { name: "botR", x: Math.floor(width * 0.9), y: Math.floor(height * 0.9) },
  ];

  let results = "";

  points.forEach(({ name, x, y }) => {
    let totalR = 0, totalG = 0, totalB = 0;

    for (let i = 0; i < 10; i++) {
      const angle = Math.random() * 2 * Math.PI; 
      const distance = Math.random() * radius;  
      const px = Math.floor(x + distance * Math.cos(angle));
      const py = Math.floor(y + distance * Math.sin(angle));

      if (px >= 0 && px < width && py >= 0 && py < height) {
        const index = (py * width + px) * 4;
        totalR += data[index];     
        totalG += data[index + 1];
        totalB += data[index + 2]; 
      }
    }

    const avgR = Math.round(totalR / 10);
    const avgG = Math.round(totalG / 10);
    const avgB = Math.round(totalB / 10);

    results += `${name}: ${avgR},${avgG},${avgB} `;
  });

  results = results.trim().replace(/;$/, "");

  const rgbDistributionElem = document.getElementById('rgbDistribution');
  rgbDistributionElem.innerHTML = `Edge distribution: ${results}`;
}

function displayEXIF(iso, aperture, exposure){
  if(!iso&&!aperture&&!exposure){exifDataElem.textContent="No EXIF.";return;}
  let shutter='N/A';
  if(exposure){shutter=exposure>=1?`${exposure.toFixed(2)}s`:`1/${Math.round(1/exposure)}`;}
  let msg=`ISO:${iso||'N/A'} | Aperture:f/${aperture?aperture.toFixed(1):'?'} | Shutter:${shutter}`;
  exifDataElem.textContent=msg;
  exifDataElem.classList.remove('good','warning');
  if((iso>200)||(aperture&&(aperture<8||aperture>16))||(exposure>1)){
    exifDataElem.classList.add('warning');
    exifDataElem.textContent+=' ⚠️ Exposure check!';
  }else exifDataElem.classList.add('good');
}

toggleButton.addEventListener('click',()=>{
  if(!imgData) return;
  overlayVisible=!overlayVisible;
  overlay.style.display=overlayVisible?'block':'none';
  if(overlayVisible) drawRedMargins();
});

function drawRedMargins() {
  octx.clearRect(0, 0, overlay.width, overlay.height);
  const mw = overlay.width * 0.05;
  const mh = overlay.height * 0.05;
  const mhb = overlay.height * 0.1;

  octx.fillStyle = "rgba(255, 0, 0, 0.4)"; // semi-transparent red bands

  octx.fillRect(0, 0, mw, overlay.height);
  octx.fillRect(overlay.width - mw, 0, mw, overlay.height);
  octx.fillRect(0, 0, overlay.width, mh);
  octx.fillRect(0, overlay.height - mhb, overlay.width, mhb);
}

toggleGridButton.addEventListener('click', () => {
  if (!imgData) return;
  gridVisible = !gridVisible;
  gridCanvas.style.display = gridVisible ? 'block' : 'none';
  if (gridVisible) drawGridOverlay();
});

function drawGridOverlay() {
  gctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
  
  const w = gridCanvas.width;
  const h = gridCanvas.height;
  
  gctx.strokeStyle = "rgba(253, 61, 181, 1)";
  gctx.lineWidth = w/300;
  
  gctx.beginPath();
  gctx.moveTo(0, 0);
  gctx.lineTo(w, h);
  gctx.stroke();
  
  gctx.beginPath();
  gctx.moveTo(w, 0);
  gctx.lineTo(0, h);
  gctx.stroke();
  
  gctx.beginPath();
  gctx.moveTo(w / 2, 0);
  gctx.lineTo(w / 2, h);
  gctx.stroke();
  
  gctx.beginPath();
  gctx.moveTo(0, h / 2);
  gctx.lineTo(w, h / 2);
  gctx.stroke();
  
  // Rule of thirds lines
  gctx.strokeStyle = "rgba(0, 255, 255, 1)"; 
  gctx.lineWidth = w/300;
  
  // Vertical thirds
  gctx.beginPath();
  gctx.moveTo(w / 3, 0);
  gctx.lineTo(w / 3, h);
  gctx.stroke();
  
  gctx.beginPath();
  gctx.moveTo((2 * w) / 3, 0);
  gctx.lineTo((2 * w) / 3, h);
  gctx.stroke();
  
  // Horizontal thirds
  gctx.beginPath();
  gctx.moveTo(0, h / 3);
  gctx.lineTo(w, h / 3);
  gctx.stroke();
  
  gctx.beginPath();
  gctx.moveTo(0, (2 * h) / 3);
  gctx.lineTo(w, (2 * h) / 3);
  gctx.stroke();
}
</script>
</body>
</html>